[{"content":"Why OAuth? Before we dive into OAuth, let\u0026rsquo;s understand why it is essential in the context of security. Every tool that humans create is done for fixing a problem, and OAuth is no different.\nLet us consider a scenario where you have stored your media files (images, videos, etc.) on a cloud storage service like Google Drive. Now, you are using a media editing application and want to edit an image/video that is stored on your Google Drive. You don\u0026rsquo;t want to download the file to your local system, edit it with the editing application, and then upload it back to Google Drive, because you find it inconvenient. Instead, you want the media editing application to directly access the file on Google Drive and make the necessary changes.\nSo, how can the media editing application access your files on Google Drive? The files are private and can only be accessed by you. One way is to provide your Google Drive credentials (username and password) to the media editing application. But this is a security risk because the application can misuse your credentials or store them insecurely. This is where OAuth comes into play. It provides a secure way for you to grant access to your Google Drive files to the media editing application without sharing your credentials.\nIn this way, OAuth enables communication between different services while maintaining the security and privacy of user data.\n2.0? Are there different versions of OAuth? In this guide, we will focus on OAuth 2.0, which is the latest version of the OAuth protocol. Other versions are OAuth 1.0 and OAuth 1.0a, which are now considered outdated due to security vulnerabilities and limitations.\nDefinition OAuth (Open Authorization) is a protocol that allows a user to grant limited access to their resources on one site to another site without sharing their credentials.\nUse Cases of OAuth 2.0 OAuth 2.0 is widely used in various scenarios to grant access to user data securely. Some common use cases of OAuth 2.0 include:\nSocial Login: Users can log in to applications using their social media accounts like Google, Facebook, or Twitter (remember the \u0026ldquo;Log in with Google\u0026rdquo; or \u0026ldquo;Log in with Facebook\u0026rdquo; buttons?). As authentication is provided by the social media accounts, this eliminates the need to create a new account and remember another set of credentials. It also lifts the burden of password management and security from the application owner. It enables Single Sign-On (SSO): Users can log in to multiple applications using a single set of credentials. API Authorization: Third-Party applications including plugins/extensions can access user data through APIs like Discord, Google Drive, Twitter, GitHub, etc. Components of OAuth 2.0 Resource Owner: The user who owns the data and grants access to it. In the Google Drive example, you are the resource owner. Client: The third-party application or website that wants to access the user\u0026rsquo;s data. In the Google Drive example, the media editing application is the client. Authorization Server: The server that authenticates the user and issues Access Tokens. In the Google Drive example, Google Drive\u0026rsquo;s authorization server. Resource Server: The server that hosts the user\u0026rsquo;s data and verifies Access Tokens. In the Google Drive example, Google Drive itself. How OAuth 2.0 Works If the users don\u0026rsquo;t share their credentials, how does OAuth 2.0 work? Through the term we mentioned earlier: \u0026ldquo;Access Tokens.\u0026rdquo; Access Tokens are like keys that allow the client to access the user\u0026rsquo;s data without knowing the user\u0026rsquo;s credentials. These tokens are short-lived and can be revoked by the user at any time. As they are short lived, we often use another key called the \u0026ldquo;Refresh Token\u0026rdquo; to get a new Access Token when the current one expires.\nOAuth 2.0 works by following a series of steps to grant access to the user\u0026rsquo;s data:\nAuthorization Request: The client sends an authorization request to the authorization server, asking for permission to access the user\u0026rsquo;s data. The set of permissions requested is known as a \u0026ldquo;scope\u0026rdquo; (e.g., read-only access, read-write access, delete access). Example: \u0026ldquo;Can I access this user\u0026rsquo;s Google Drive files?\u0026rdquo; User Authentication: The user authenticates with the authorization server and grants permission to the client. (You should always check the scope of permissions requested before granting access). Example: You log in to your Google account and authorize the media editing application to access your Google Drive files. Access Token Request: The client sends a request to the authorization server for an Access Token. Example: The media editing application requests an Access Token to access your Google Drive files. Access Token Grant: The authorization server issues an Access Token to the client. Example: Google Drive issues an Access Token to the media editing application. Access Resource: The client sends the Access Token to the resource server to access the user\u0026rsquo;s data. Example: The media editing application uses the Access Token to access your Google Drive files. Resource Access: The resource server verifies the Access Token and grants access to the user\u0026rsquo;s data. Example: Google Drive verifies the Access Token and allows the media editing application to access your files. Conclusion OAuth 2.0 is a powerful and secure protocol that allows users to grant access to their data without sharing their credentials. It is widely used in various applications and scenarios to provide a secure and flexible way to access user data. Understanding OAuth 2.0 is essential for developers who want to build secure and user-friendly applications that interact with third-party services.\n","permalink":"http://localhost:1313/blogs/what_is_oauth_2.0_definition_use_cases_and_how_it_works/","summary":"A comprehensive guide to understanding OAuth (2.0), its definition, use cases, and how it works to grant secure access to user data.","title":"What Is OAuth (2.0)? | Definition, Use Cases, and How it Works"},{"content":"Background: I was tasked with extending an e-sports FIFA tournament service (SAFA) that had been operating primarily on Discord through a Discord bot, to the web. The aim was to develop a web interface by integrating it with Discord, which provides OAuth authentication. Since the database for users was modeled around their Discord account ID, I implemented login functionality using Discord OAuth and JWT tokens.\nAuthorization Workflow: Initially, the user is logged out. Upon login, an access token and refresh token are created, both stored as JWTs in cookies. The access token is sent with all requests (via the bearer authorization header), while the refresh token is only sent to a specific refresh endpoint (/refresh). The backend verifies these tokens (JWT verification) whenever frontend makes a request to it.\nIf verification fails for reasons other than expiration, the user is logged out. If the token has expired, the frontend silently attempts to refresh it by sending a request to backend at /refresh. If the refresh is successful, new access and refresh tokens are issued, and the original request is retried. If any error occurs during this process, including token expiry, the user is logged out.\nThe Problem: This process works well when only one request is sent at a time. However, since the website uses client-side rendering (CSR) and is a single-page application (SPA) built with React, users often send multiple AJAX requests simultaneously. This can lead to unintended session termination due to concurrent refresh attempts which logs the user out.\nWhy does this happen? When the access token has expired, the first request to the backend triggers a refresh and retrieves new tokens. However, before these new tokens are updated to the frontend, other requests are sent with the old tokens. If those requests also try to refresh the tokens, Discord returns an error (403) because the refresh token has already been used. This causes the system to terminate the user\u0026rsquo;s session thereby logging them out.\nSolution Options: Extend token expiration periods: This reduces the frequency of refreshes and unintended session terminations, but it introduces security risks and is not a proper solution. Queue requests: When the frontend detects an expired token, it queues the requests until the refresh is completed. This can slow down the app, especially when expiration times are short. Locking mechanism of Refresh Token: The backend uses locks on Refresh Tokens, ensuring that only one refresh attempt for a Refresh Token is processed at a time. The Chosen Solution: Redis-based Locking Mechanism I chose to implement a locking mechanism using Redis, a fast in-memory data store with built-in key expiry.\nWe allow the first request to refresh the token while the others wait for the result of the first request. Here’s how it works:\nThe backend returns Token expiration error, the frontend then sends a refresh request to the backend at /refresh. Two Redis keys are used: refresh_token_lock:\u0026lt;Refresh Token\u0026gt;: Indicates whether the refresh token is being processed. refresh_token:\u0026lt;Refresh Token\u0026gt;: Holds the result status of the refresh attempt for the Token. At /refresh backend first checks if a refresh_token:\u0026lt;Refresh Token\u0026gt; key exists in Redis. If it does, the system returns the corresponding status. If the key does not exist, we check for the refresh_token_lock:\u0026lt;Refresh Token\u0026gt; key to see if another request has acquired the lock. If the lock is held, the request waits for it to be released and then checks the status key again. If no lock is present, the request acquires the lock, performs the refresh, and sets the appropriate status key in Redis. The lock is then released, and the status is returned. This ensures that only the first request refreshes the token, while other requests wait for the result.\nConclusion: The Redis-based locking mechanism effectively handles and prevents concurrent refresh attempts and ensures that only one request is allowed to refresh tokens at a time. This solution enhances the overall reliability and security of token management in the system.\ntags: [OAuth, JWT, Redis, Security, Web Development]\n","permalink":"http://localhost:1313/blogs/overcoming-concurrent-refresh-attempts-of-access-tokens-jwt/","summary":"A deep dive into handling concurrent refresh attempts of access tokens in a single-page application using JWT, OAuth, and Redis-based locking mechanisms to enhance token management security.","title":"Overcoming Concurrent Refresh Attempts of Access Tokens (JWT)"},{"content":"Background I was tasked with developing a web interface for an e-sports FIFA tournament service (SAFA) that had been operating primarily on Discord. They wanted to extend their services to a website, and I was responsible for making it happen.\nAfter a new user joins their Discord server, before they could interact further (e.g., searching/joining teams), they were required to update their profile using a form. After which, they were given the role \u0026ldquo;updated-profile\u0026rdquo; and \u0026ldquo;free-agent\u0026rdquo; (not present in any team). A player, if present in a team, has the role \u0026ldquo;player\u0026rdquo;.\nThe Problem: API Rate Limits Whenever a user registers or logs into the website using Discord OAuth, the dashboard view presented to them is based on their roles within the Discord server. The roles dictate what actions the user can take:\nIs the user part of the Discord server? (If not, prompt them to join) Has the user updated their profile? (If not, show the form) Is the user a \u0026ldquo;free-agent\u0026rdquo;? (If yes, provide options to join/create a team) Is the user a \u0026ldquo;team manager\u0026rdquo;? (If yes, provide team management options) These role details are fetched from the Discord API. However, the API has strict rate limits: 5 requests per minute, with a soft reset allowing 1 request per minute after. The rate limit applies to a specific Access Token for a Discord server.\nSince user roles can change based on interactions through their existing Discord Bot (e.g., joining a team), we needed to re-fetch roles each time the browser tab was re-focused or reloaded. In a React development environment with StrictMode enabled, each component renders twice, which doubled the number of API requests, often resulting in the API being rate-limited.\nThe Solution Options There were two main approaches to handle this issue:\nBuild a Discord Bot and Maintain Internal User Data: This option would involve using WebSockets to track user role changes in real-time and storing this data in a database. While this would ensure up-to-date information, it introduces significant complexity and resource overhead.\nCache Fetched Data from the Discord API: This simpler solution involves caching user roles from the Discord API in a memory store (like Redis) to avoid hitting the rate limit. The trade-off is a delay in real-time data (maximum of 1 minute), but this was acceptable for our use case.\nWe opted for the caching approach using Redis, as it provides both time efficiency and native data expiry.\nThe Solution: Fetch with Cache Fallback We implemented a fetch-with-cache fallback mechanism. Here’s how it works:\n1. Check for Rate-Limit Key: Before making a request, we check if we’ve been rate-limited by looking for a Redis key of the pattern discord_roles_\u0026lt;ServerID\u0026gt;_\u0026lt;AccessToken\u0026gt;_retry-after. This key is created when a previous request was rate-limited.\n2. Handle Rate-Limited Requests: If this key exists, we don’t attempt to make a new API call. Instead, we return the cached data stored in Redis with the key of pattern discord_roles_\u0026lt;ServerID\u0026gt;_\u0026lt;UserID\u0026gt;, ensuring the user doesn’t see outdated information.\n3. Make API Request: If the rate-limit key isn’t found, we proceed to fetch the user’s roles from the Discord API.\nIf the request is successful, we cache the returned data with a key of the pattern discord_roles_\u0026lt;ServerID\u0026gt;_\u0026lt;UserID\u0026gt; and return it. If the request hits a rate-limit error, we create the key discord_roles_\u0026lt;ServerID\u0026gt;_\u0026lt;AccessToken\u0026gt;_retry-after with an expiry set to the rate-limit reset time (plus 1 second). After this, we return the previously cached data. This approach minimized unnecessary API calls while ensuring that users received role-based data quickly, even during rate-limited periods.\nWhat I Learned and Future Considerations While this solution worked well for our use case, I realized that using Redis opened up more possibilities for handling similar challenges elsewhere in the project. For instance, I later used Redis to solve another issue related to concurrent refresh attempts of access tokens.\nIn retrospect, there is an improvement we could consider for future versions: Partial WebSocket Implementation: Given the requirement for very specific role updates, partial WebSocket integration could help fetch only critical updates in real-time without introducing unnecessary overhead.\nConclusion A simple fetch-with-cache fallback system using Redis allowed us to deliver a smooth user experience while adhering to Discord’s API constraints. The combination of simplicity and effectiveness made Redis a good fit for this project.\n","permalink":"http://localhost:1313/blogs/overcoming-discord-api-rate-limits-with-redis-cache/","summary":"How to handle (Discord) API rate limits using a Redis-based caching mechanism in a web application.","title":"Overcoming (discord) API Rate Limits With Redis Cache"}]