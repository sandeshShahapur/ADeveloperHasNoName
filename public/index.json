[{"content":"Background: I was tasked with developing a web interface for an e-sports FIFA tournament service (SAFA) that had been operating primarily on Discord. They wanted to extend their services to a website, and I was responsible for making it happen. Because the database for users was modeled around their discord account ID, the website required integrating with Discord. As Discord provides an OAuth service (OAuth explained), by using JWT (learn what JWT is here) I implemented login feature through Discord OAuth (learn how to do it yourself here).\nAuthorization Workflow Initially, the user is logged out. When they log in, an access token and refresh token is created and the access token (AT) is stored in a cookie and thereafter sent in with all requests (bearer authorization header) while RT is stored in httpOnly cookies and that is only sent to the refresh path request. With every request, the backend verifies the signature. If signature mismatches, the user or any other issue (other than expiry), the user is logged out. If the token is expired, the frontend will make a request to refresh silently and will issue new AT \u0026amp; RT (point: the RT used to refresh is now exhausted) and the frontend retries the original request (if this time any token-related issue including expiry will log or logout the user).\nProblem The workflow works well when the frontend sends only one request around the same time period. However, say when a user returns to their session and (hopefully) a page reloads or navigates to new UI often the screen is refreshed, or multiple hosts of the website could be making requests (example - page fetching user details say for navbar or whole page, multiple hosts of webpage making AJAX requests, etc.), the user ends up being logged out.\nWhy does this happen? All these let us consider the original/first request: it goes through our workflow and stores new AT/RT while succeeding with its request. However, by the time it stores the new AT/RT, other requests would have carried with it the old AT (which isn’t the problem) AND the old RT and when they attempt to refresh the AT, discord returns error 403 because we have already made use of that RT. As the request attempt of this request failed, it then logs out the user. Thus, the issue is concurrent attempts of refreshing access tokens.\nApproach to solution What are our options?\nWe extend expiry periods such that logging out occurs unfrequently but is infrequent. This is not really a solution and it is a security issue.\nWe limit the number of refresh requests after a time period. This can be implemented but it makes our app slow and it does not scale.\nWe check for expiry before making a request if possible and then allow only one request at a time. This will make the site slow. Although, can be implemented with global locking.\nLocking mechanism at backend. We borrow the idea of using locks from processor idea to have it in place at the backend. To use what speed, a memcache such as Redis is optimal. It is reliable and widely provides best efficiency.\nSolution Workflow of distributed locking mechanism using Redis:\nThe frontend mechanism is unchanged.\nWhen a refresh attempt is made to refresh, we first check if there is an entry in Redis for the RT of the request. If there is not, I acquire a lock on it by inserting an entry of that key/refresh token in Redis with the value being “processing”. After either succeeding or failing with the refresh attempt, I update the status of my entry lock such as expiry of the lock and return the appropriate status for the request.\nHowever, if the lock exists, I will not try to refresh the token. Instead, I will wait until the status of the lock is not “processing”. After which, depending on the result of the original request, I return the status as indicated by the lock. This ensures that only the first original request attempts to refresh while the others wait to find out if the original was a success or a failure.\n","permalink":"http://localhost:1313/blogs/overcoming-concurrent-refresh-attempts-of-access-tokens-jwt/","summary":"\u003ch2 id=\"background\"\u003eBackground:\u003c/h2\u003e\n\u003cp\u003eI was tasked with developing a web interface for an e-sports FIFA tournament service (SAFA) that had been operating primarily on Discord. They wanted to extend their services to a website, and I was responsible for making it happen.\nBecause the database for users was modeled around their discord account ID, the website required integrating with Discord. As Discord provides an OAuth service (\u003ca href=\"/content/blogs/overcoming-(discord)-api-rate-limits-with-redis-cache.md\"\u003eOAuth explained\u003c/a\u003e), by using JWT (learn what JWT is here) I implemented login feature through Discord OAuth (learn how to do it yourself here).\u003c/p\u003e","title":"Overcoming Concurrent Refresh Attempts of Access Tokens (Jwt)"},{"content":"Background I was tasked with developing a web interface for an e-sports FIFA tournament service (SAFA) that had been operating primarily on Discord. They wanted to extend their services to a website, and I was responsible for making it happen.\nAfter a new user joins their Discord server, before they could interact further (e.g., searching/joining teams), they were required to update their profile using a form. After which, they were given the role \u0026ldquo;updated-profile\u0026rdquo; and \u0026ldquo;free-agent\u0026rdquo; (not present in any team). A player, if present in a team, has the role \u0026ldquo;player\u0026rdquo;.\nThe Problem: API Rate Limits Whenever a user registers or logs into the website using Discord OAuth, the dashboard view presented to them is based on their roles within the Discord server. The roles dictate what actions the user can take:\nIs the user part of the Discord server? (If not, prompt them to join) Has the user updated their profile? (If not, show the form) Is the user a \u0026ldquo;free-agent\u0026rdquo;? (If yes, provide options to join/create a team) Is the user a \u0026ldquo;team manager\u0026rdquo;? (If yes, provide team management options) These role details are fetched from the Discord API. However, the API has strict rate limits: 5 requests per minute, with a soft reset allowing 1 request per minute after. The rate limit applies to a specific Access Token for a Discord server.\nSince user roles can change based on interactions through their existing Discord Bot (e.g., joining a team), we needed to re-fetch roles each time the browser tab was re-focused or reloaded. In a React development environment with StrictMode enabled, each component renders twice, which doubled the number of API requests, often resulting in the API being rate-limited.\nThe Solution Options There were two main approaches to handle this issue:\nBuild a Discord Bot and Maintain Internal User Data: This option would involve using WebSockets to track user role changes in real-time and storing this data in a database. While this would ensure up-to-date information, it introduces significant complexity and resource overhead.\nCache Fetched Data from the Discord API: This simpler solution involves caching user roles from the Discord API in a memory store (like Redis) to avoid hitting the rate limit. The trade-off is a delay in real-time data (maximum of 1 minute), but this was acceptable for our use case.\nWe opted for the caching approach using Redis, as it provides both time efficiency and native data expiry.\nThe Solution: Fetch with Cache Fallback We implemented a fetch-with-cache fallback mechanism. Here’s how it works:\n1. Check for Rate-Limit Key: Before making a request, we check if we’ve been rate-limited by looking for a Redis key of the pattern discord_roles_\u0026lt;ServerID\u0026gt;_\u0026lt;AccessToken\u0026gt;_retry-after. This key is created when a previous request was rate-limited.\n2. Handle Rate-Limited Requests: If this key exists, we don’t attempt to make a new API call. Instead, we return the cached data stored in Redis with the key of pattern discord_roles_\u0026lt;ServerID\u0026gt;_\u0026lt;UserID\u0026gt;, ensuring the user doesn’t see outdated information.\n3. Make API Request: If the rate-limit key isn’t found, we proceed to fetch the user’s roles from the Discord API.\nIf the request is successful, we cache the returned data with a key of the pattern discord_roles_\u0026lt;ServerID\u0026gt;_\u0026lt;UserID\u0026gt; and return it. If the request hits a rate-limit error, we create the key discord_roles_\u0026lt;ServerID\u0026gt;_\u0026lt;AccessToken\u0026gt;_retry-after with an expiry set to the rate-limit reset time (plus 1 second). After this, we return the previously cached data. This approach minimized unnecessary API calls while ensuring that users received role-based data quickly, even during rate-limited periods.\nWhat I Learned and Future Considerations While this solution worked well for our use case, I realized that using Redis opened up many more possibilities for managing caching and handling similar challenges elsewhere in the project. For instance, I later used Redis to solve another issue related to concurrent refresh attempts of access tokens.\nIn retrospect, there is an improvement we could consider for future versions: Partial WebSocket Implementation: Given the requirement for very specific role updates, partial WebSocket integration could help fetch only critical updates in real-time without introducing unnecessary overhead.\nConclusion A simple fetch-with-cache fallback system using Redis allowed us to deliver a smooth user experience while adhering to Discord’s API constraints. The combination of simplicity and effectiveness made Redis a good fit for this project.\n","permalink":"http://localhost:1313/blogs/overcoming-discord-api-rate-limits-with-redis-cache/","summary":"How to handle (Discord) API rate limits using a Redis-based caching mechanism in a web application.","title":"Overcoming (discord) API Rate Limits With Redis Cache"}]